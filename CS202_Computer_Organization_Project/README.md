# CS202_Computer_Organization

**小组成员：沈泓立、郑袭明、刘安钊**

------

### 开发者说明

| 姓名   | 学号     | 负责内容                                   | 贡献比 |
| ------ | -------- | ------------------------------------------ | ------ |
| 沈泓立 | 12311016 | CPU和IO部分的实现与测试，文档写作          | 1/3    |
| 郑袭明 | 12311011 | CPU硬件测试，VGA，uart，文档写作           | 1/3    |
| 刘安钊 | 12311020 | CPU硬件测试，测试场景1+2汇编代码，文档写作 | 1/3    |

### 开发日程

#### 原计划

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 测试场景1+2测试
- 5.19 - 5.25 bonus部分实现

#### 实际安排

- 5.1 - 5.5 CPU子模块实现
- 5.6 - 5.11 CPU顶层模块+子模块测试
- 5.12 - 5.18 CPU顶层模块仿真测试
- 5.19 - 5.21 测试场景1通过+VGA
- 5.22 - 5.23 测试场景2通过+uart
- 5.24 文档协作

### CPU架构设计说明

#### CPU特性

**ISA**：

| R-type | opcode  | funct3 | funct7   | 使用方法                |
| ------ | ------- | ------ | -------- | ----------------------- |
| add    | 0110011 | 000    | 000_0000 | rd = rs1 + rs2          |
| sub    | 0110011 | 000    | 010_0000 | rd = rs1 - rs2          |
| xor    | 0110011 | 100    | 000_0000 | rd = rs1 ˆ rs2          |
| or     | 0110011 | 110    | 000_0000 | rd = rs1 \| rs2         |
| and    | 0110011 | 111    | 000_0000 | rd = rs1 & rs2          |
| sll    | 0110011 | 001    | 000_0000 | rd = rs1 « rs2          |
| srl    | 0110011 | 101    | 000_0000 | rd = rs1 » rs2          |
| sra    | 0110011 | 101    | 010_0000 | rd = rs1 » rs2 (Arith*) |
| slt    | 0110011 | 010    | 000_0000 | rd = (rs1 < rs2)?1:0    |
| sltu   | 0110011 | 011    | 000_0000 | rd = (rs1 < rs2)?1:0    |

| I-type-1 | opcode  | funct3 | funct7             | 使用方法                     |
| -------- | ------- | ------ | ------------------ | ---------------------------- |
| addi     | 0010011 | 000    | null               | rd = rs1 + imm               |
| xori     | 0010011 | 100    | null               | rd = rs1 ˆ imm               |
| ori      | 0010011 | 110    | null               | rd = rs1 \| imm              |
| andi     | 0010011 | 111    | Null               | rd = rs1 & imm               |
| slli     | 0010011 | 001    | imm[11:5]=000_0000 | rd = rs1 « imm[4:0]          |
| srai     | 0010011 | 101    | imm[11:5]=010_0000 | rd = rs1 » imm[4:0] (Arith*) |
| srli     | 0010011 | 101    | imm[11:5]=000_0000 | rd = rs1 » imm[4:0]          |

| I-type-2 | opcode  | 使用说明                                                     |
| -------- | ------- | ------------------------------------------------------------ |
| lw       | 0000011 | 在IO输入过程中，我们通过switch取值范围来区分lb, lh, lw, lbu, lhu |

| S-type | opcode  | 使用方法                      |
| ------ | ------- | ----------------------------- |
| sw     | 0100011 | M \[rs1+imm][31:0]= rs2[31:0] |

| B-type | opcode  | funct3 | 使用方法                            |
| ------ | ------- | ------ | ----------------------------------- |
| beq    | 1100011 | 000    | if(rs1 == rs2) PC = PC + {imm,1’b0} |
| bne    | 1100011 | 001    | if(rs1 != rs2) PC = PC + {imm,1’b0} |
| blt    | 1100011 | 100    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bge    | 1100011 | 101    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |
| bltu   | 1100011 | 110    | if(rs1 < rs2) PC = PC + {imm,1’b0}  |
| bgeu   | 1100011 | 111    | if(rs1 >= rs2) PC = PC + {imm,1’b0} |

| J-type | opcode  | 使用方法                        |
| ------ | ------- | ------------------------------- |
| jal    | 1101111 | rd = PC+4; PC = PC + {imm,1’b0} |

| I-type-3 | opcode  | func3 | 使用方法                  |
| -------- | ------- | ----- | ------------------------- |
| jalr     | 1100111 | 000   | rd = PC+4; PC = rs1 + imm |

| U-type | opcode  | 使用方法      |
| ------ | ------- | ------------- |
| lui    | 0110111 | rd = imm « 12 |

| bonus | opcode  | 使用方法             |
| ----- | ------- | -------------------- |
| auipc | 0010111 | rd = PC + (imm « 12) |

**参考的ISA**：RISC-V，具体使用方式请详见RISC-V Reference Card

**寄存器说明**：

​	本项目按照RISC-V 标准定义了 32 个通用寄存器，每个寄存器 32 位宽度：

- x0: 始终为零
- x1-x31: 通用寄存器，用于数据和地址操作

该CPU属于**单周期CPU**，不支持pipeline

**CPU时钟周期**：10kHz

**寻址空间设计**：本系统采用哈佛结构，指令存储与数据存储物理分离。指令空间从 地址 `0x00000000` 开始，数据存储区从地址 `0x00001000` 开始，供程序变量使用；栈空间从地址 `0x00002000` 向下增长，用于函数调用与返回。同时，系统采用 Memory-Mapped I/O 机制，在数据存储空间的高位保留一段地址（ `0xFFFFFF00 ~ 0xFFFFFFFF`）用于内存映射 I/O：数码管地址为 `0xfffffff0`，led地址为 `0xffffffc2` 等。

**外设IO设计**：采用`MMIO`设计方案，根据地址来判断switch读取比特数以及采用LED输出或数码管输出，具体如下：

| IO-input                        | 地址          |
| ------------------------------- | ------------- |
| switch读取`confirm`按钮（1bit） | 32'hffff_ff00 |
| switch读取16位按键              | 32'hffff_fff1 |
| switch读取高8位（unsigned）     | 32'hffff_fff3 |
| switch读取低8位（signed）       | 32'hffff_fff5 |
| switch读取低3位（unsigned）     | 32'hffff_fff7 |
| switch读取低8位（unsigned）     | 32'hffff_fff9 |

| IO-output          | 地址          |
| ------------------ | ------------- |
| 数码管显示16进制数 | 32'hffff_fff0 |
| LED灯亮右侧8个     | 32'hffff_ffc2 |
| 数码管显示10进制数 | 32'hffff_ffc4 |

#### CPU接口

```verilog
module CPU (
    input clk,                  // 原始时钟 100MHz
    input reset,                // 全局复位
    input [15:0] switchInput,   // 来自拨码开关的输入
    input enter,         // 模拟确认按键
    input start_pg,     //recieve data by UART
    input rx,           //send data by UART

    output tx,
    output [7:0] tubSel,        // 数码管位选
    output [7:0] seg_led1234,       // 左侧段选
    output [7:0] seg_led5678,      // 右侧段选
    output [15:0] dataOut,
);
```

##### **cpuclk 模块**

| 接口名   | 方向   | 位宽 | 说明                          |
| -------- | ------ | ---- | ----------------------------- |
| clk_in1  | input  | 1    | 输入主时钟                    |
| clk_out1 | output | 1    | 分频时钟输出1（用于CPU逻辑）  |
| clk_out2 | output | 1    | 分频时钟输出2（用于UART编程） |

##### **uart_bmpg_0 模块（uart）**

| 接口名     | 方向   | 位宽 | 说明             |
| ---------- | ------ | ---- | ---------------- |
| upg_clk_i  | input  | 1    | UART编程时钟输入 |
| upg_rst_i  | input  | 1    | UART复位         |
| upg_rx_i   | input  | 1    | UART RX输入      |
| upg_clk_o  | output | 1    | UART输出时钟     |
| upg_wen_o  | output | 1    | 写使能           |
| upg_adr_o  | output | 15   | 写地址           |
| upg_dat_o  | output | 32   | 写数据           |
| upg_done_o | output | 1    | 写完成标志       |
| upg_tx_o   | output | 1    | UART TX输出      |

##### **IFetch 模块**

| 接口名        | 方向   | 位宽 | 说明              |
| ------------- | ------ | ---- | ----------------- |
| clk           | input  | 1    | CPU时钟           |
| rst           | input  | 1    | 复位              |
| imm32         | input  | 32   | 立即数            |
| branch_result | input  | 1    | 跳转判断结果      |
| zero          | input  | 1    | ALU零标志         |
| jal           | input  | 1    | 跳转指令          |
| jalr          | input  | 1    | 寄存器跳转指令    |
| Alu_result    | input  | 32   | 来自ALU的地址结果 |
| upg_rst       | input  | 1    | UART复位          |
| upg_clk       | input  | 1    | UART时钟          |
| upg_wen_o     | input  | 1    | UART写使能        |
| upg_adr_o     | input  | 15   | UART写地址        |
| upg_dat_o     | input  | 32   | UART写数据        |
| upg_done_o    | input  | 1    | UART写完成        |
| instruction   | output | 32   | 取出的指令        |
| pc_out        | output | 32   | 下一个PC地址      |
| pc_now        | output | 32   | 当前PC地址        |

##### **instruction_control 模块**

| 接口名       | 方向   | 位宽 | 说明           |
| ------------ | ------ | ---- | -------------- |
| instruction  | input  | 32   | 指令           |
| Alu_result   | input  | 32   | ALU 结果       |
| a7           | output | 1    | 系统调用标识位 |
| nBranch      | output | 1    | 非条件分支     |
| Branch       | output | 1    | 条件分支       |
| branch_lt    | output | 1    | 小于分支       |
| branch_ge    | output | 1    | 大于等于分支   |
| branch_ltu   | output | 1    | 无符号小于分支 |
| branch_geu   | output | 1    | 无符号大于等于 |
| jal          | output | 1    | 无条件跳转     |
| jalr         | output | 1    | 寄存器跳转     |
| MemRead      | output | 1    | 读存储器       |
| MemorIOToReg | output | 1    | 存储器/IO选择  |
| ALUop        | output | 4    | ALU 操作码     |
| MemWrite     | output | 1    | 写存储器       |
| ALUSrc       | output | 1    | ALU源选择      |
| RegWrite     | output | 1    | 写寄存器       |
| sftmd        | output | 1    | 移位操作使能   |
| IORead       | output | 1    | IO读           |
| IOWrite      | output | 1    | IO写           |

##### **reg_and_imm 模块**

| 接口名      | 方向   | 位宽 | 说明           |
| ----------- | ------ | ---- | -------------- |
| clk         | input  | 1    | 时钟           |
| rst         | input  | 1    | 复位           |
| inst        | input  | 32   | 指令           |
| write_data  | input  | 32   | 写入寄存器数据 |
| RegWrite    | input  | 1    | 写使能         |
| read_data_1 | output | 32   | 源寄存器1数据  |
| read_data_2 | output | 32   | 源寄存器2数据  |
| imm32       | output | 32   | 立即数         |
| a7          | output | 1    | 系统调用标识位 |

##### **ALU 模块**

| 接口名        | 方向   | 位宽 | 说明             |
| ------------- | ------ | ---- | ---------------- |
| ALUop         | input  | 4    | ALU操作码        |
| ALUSrc        | input  | 1    | ALU源选择        |
| sftmd         | input  | 1    | 是否为移位操作   |
| Branch        | input  | 1    | 分支控制信号     |
| nBranch       | input  | 1    | 非条件分支       |
| Branch_lt     | input  | 1    | 小于分支判断     |
| Branch_ge     | input  | 1    | 大于等于分支判断 |
| Branch_ltu    | input  | 1    | 无符号小于判断   |
| Branch_geu    | input  | 1    | 无符号大于等于   |
| read_data_1   | input  | 32   | 操作数1          |
| read_data_2   | input  | 32   | 操作数2          |
| imm32         | input  | 32   | 立即数           |
| pc            | input  | 32   | 当前指令地址     |
| Alu_result    | output | 32   | ALU输出          |
| zero          | output | 1    | 零标志           |
| branch_result | output | 1    | 分支结果         |

##### **Data_mem 模块**

| 接口名     | 方向   | 位宽 | 说明                 |
| ---------- | ------ | ---- | -------------------- |
| clk        | input  | 1    | 时钟                 |
| m_read     | input  | 1    | 读使能               |
| m_write    | input  | 1    | 写使能               |
| addr       | input  | 32   | 地址                 |
| d_in       | input  | 32   | 写入数据             |
| d_out      | output | 32   | 读取数据             |
| upg_rst_i  | input  | 1    | UART复位             |
| upg_clk_i  | input  | 1    | UART时钟             |
| upg_wen_i  | input  | 1    | UART写使能           |
| upg_adr_i  | input  | 14   | UART写地址（低14位） |
| upg_dat_i  | input  | 32   | UART写数据           |
| upg_done_i | input  | 1    | UART写完成标志       |

##### **MemOrIO 模块**

| 接口名     | 方向   | 位宽 | 说明             |
| ---------- | ------ | ---- | ---------------- |
| mRead      | input  | 1    | 内存读           |
| mWrite     | input  | 1    | 内存写           |
| ioRead     | input  | 1    | IO读             |
| ioWrite    | input  | 1    | IO写             |
| addr_in    | input  | 32   | ALU输出地址      |
| addr_out   | output | 32   | 仲裁后的输出地址 |
| m_rdata    | input  | 32   | 内存读数据       |
| io_rdata   | input  | 16   | IO读数据         |
| r_wdata    | output | 32   | 写入数据         |
| r_rdata    | input  | 32   | 寄存器读数据     |
| write_data | output | 32   | 最终写入总线数据 |
| LEDCtrl    | output | 1    | 控制LED          |
| SwitchCtrl | output | 1    | 控制开关输入     |

##### **writeback_mux 模块**

| 接口名         | 方向   | 位宽 | 说明             |
| -------------- | ------ | ---- | ---------------- |
| MemorIOToReg   | input  | 1    | 写回源选择信号   |
| Alu_result     | input  | 32   | ALU计算结果      |
| r_wdata        | input  | 32   | 数据读取结果     |
| pc_out         | input  | 32   | 跳转指令返回地址 |
| jal            | input  | 1    | 是否为跳转指令   |
| writeback_data | output | 32   | 写回寄存器的数据 |

##### **IO 模块**

| 接口名       | 方向   | 位宽 | 说明           |
| ------------ | ------ | ---- | -------------- |
| clk          | input  | 1    | 时钟           |
| rst          | input  | 1    | 复位           |
| switchCtrl   | input  | 1    | 开关控制信号   |
| r_wdata      | input  | 32   | 写入IO的数据   |
| LEDCtrl      | input  | 1    | 控制LED信号    |
| switchInput  | input  | 16   | 开关输入值     |
| address      | input  | 32   | 地址           |
| confirmation | input  | 1    | 确认按键信号   |
| writeData    | input  | 32   | 外设写入数据   |
| dataIOInput  | output | 16   | 外设读出数据   |
| tubSel       | output | 8    | 数码管位选     |
| tubLeft      | output | 8    | 数码管左段选   |
| tubRight     | output | 8    | 数码管右段选   |
| dataOut      | output | 16   | IO结果数据输出 |

**时钟信号说明：**在本 CPU 中使用到了开发板提供的 100MHz 时钟 `Y18` ，通过 IP 核分别转化成为了 10kHz（供cpu 使用）、10MHz（供uart使用)

**复位信号说明：**使用异步复位，我们通过高电位信号来判断复位信号并通过开发板的按钮外设来控制复位信号的输入。在按下复位按钮之后， CPU 将会重新回到初始状态，之前的所有状态将会被清空。

**uart接口说明：**UART用于 CPU 与外部设备之间进行数据传输。该接口仅需两根信号线：`rx`（接收端）：接收外部串口数据；`tx`（发送端）：将数据发送到外部设备。通信采用异步传输方式，将inst.txt 和mem.txt生成的out.txt直接烧写到开发版上。

**IO输出接口说明**：led 0-7 号灯根据测试场景可以作为指示信号灯，若判断关系成立则亮灯，反之不亮，也可以展示二进制结果。七段数码管用来显示测试场景中输入的数字和计算后的数字。

### 方案分析说明

#### 浮点数运算在硬件与软件实现上的比较分析

**硬件方案实现：**

在 CPU 指令执行阶段，我们通过手动解析浮点数的 IEEE 754 表示格式，将其符号位、指数位与尾数位逐一提取，并对尾数补齐隐含的最高位“1”，结合指数偏移量进行偏移还原，从而完成对浮点值的还原和整数部分的提取。具体计算中，需根据指数大小对尾数进行左移或右移，以实现乘以或除以 2 的幂次效果，最终得到近似的整数值。该处理流程可完全在 CPU 内部的数据通路中实现，避免了对额外指令序列的依赖，具有较高的执行效率。

然而，正因该方案在硬件中以组合逻辑的方式直接实现浮点值的解析与运算，涉及的操作链条较长，包括尾数对齐、指数计算、移位器调度、条件判断与规格化等多个模块的级联。这一过程在逻辑上虽然清晰，但会显著拉长 ALU 的关键路径延迟，进而对 CPU 的工作时钟周期产生负面影响。特别是在单周期处理器架构下，系统的最短时钟周期必须覆盖整个浮点运算路径，导致整体时钟频率下降，成为影响主频上限和系统吞吐性能的潜在瓶颈。

**软件方案实现：**

在本项目中，由于 CPU 架构本身不直接支持浮点数相关指令，我们采用了汇编语言对浮点运算进行软件层模拟。具体策略是将输入的二进制数通过 ×16 的方式放大（相当于将小数点右移 4 位），并以整数形式参与后续的加减操作，从而在不引入浮点指令的前提下，实现对浮点数加法与取整的功能。

```
decode_float12:
    andi t3, t3, 0xFF         # 清除高位，仅保留 t3 的低 8 位作为浮点编码（格式 SEEMMMMM）

    srli t0, t3, 7            # t0 = S，符号位（bit[7]）

    andi t1, t3, 0x70         # 提取指数原始值 e_raw，位于 bit[6:4]
    srli t1, t1, 4            # t1 = e_raw（去掉低 4 位和符号位）

    li t4, 3
    sub t1, t1, t4            # t1 = E = e_raw - bias（偏移量 bias = 3）

    andi t2, t3, 0x0F         # t2 = M，尾数低 4 位，bit[3:0]

    li t5, 16
    add a0, t2, t5            # a0 = 16 + M = 1.M 的整数放大表示（1×16 + M）
                              # 例如 M=3 → a0=19，表示 1.1875

    bgez t1, shift_left       # 如果 E >= 0：向左移（放大）
    neg t6, t1                # 否则 E 为负，先取其绝对值
    srl a0, a0, t6            # 右移 a0，表示除以 2^|E|（向右平移小数点）
    j done                    # 跳转到 done

shift_left:
    sll a0, a0, t1            # 左移 a0，表示乘以 2^E（向左平移小数点）

done:
    srli a0, a0, 4            # 因为 a0 中原始数放大了 16 倍（即 4 位），这里右移 4 位还原整数部分
    jr ra                     # 返回结果 a0（无符号整数）
```

该软件方案的主要优势在于开发灵活、调试高效：无需修改底层硬件，仅需编写或调整指令序列即可快速实现功能更新，便于在原型设计、功能验证和教学实验中使用。

尽管如此，软件模拟方案在性能上仍存在劣势。每一次浮点数的处理通常需要经过多个步骤，如移位、加法、舍入和还原，指令条数较多，占用执行周期长，容易成为整体程序运行的瓶颈。同时，由于采用定点数近似运算，数据精度受到整数位宽限制，若操作数超出精度范围，可能导致截断误差或结果偏差。

为缓解这些问题，软件方案仍具备一定的优化空间，主要包括以下方向：

1. **封装通用浮点运算宏**：将常用浮点操作（如“定点加+右移取整”）封装为宏或伪指令接口，以提升代码复用率、减少冗余指令数量。
2. **查表替代复杂运算**：对于常用的指数或浮点转整数结果，可事先构造查找表，通过内存读取完成计算，换空间以提升时间性能。
3. **优化精度调度策略**：根据目标应用场景适配不同精度参数（如 ×8、×32 定点倍数），在精度与性能之间动态权衡，提高结果质量。

综上，虽然软件方案在高性能场景下存在天然劣势，但通过合理优化与融合设计，仍能实现较高性价比的浮点数处理能力。

**对比结果总结：**

| 比较维度 | 硬件实现                     | 软件实现                         |
| -------- | ---------------------------- | -------------------------------- |
| 性能     | 快速、执行周期短             | 多指令实现，执行时间长           |
| 精度     | 可实现较高精度，取决于电路逻辑设计 | 易受定点数精度影响               |
| 实现难度 | 复杂，需理解底层电路逻辑     | 相对简单，灵活性高               |
| 可调试性 | 需仿真+上板调试，较为困难    | 可直接观察输出结果，易修改和调试 |

**最终选择说明：**

在本次项目中，我们综合考虑了开发进度、系统复杂度与调试成本，最终选择采用**软件实现方案**来完成浮点数取整功能的开发。相比硬件实现，软件方案无需增加额外的运算单元，能够以更低的成本快速实现功能原型，并在调试过程中提供更高的灵活性。虽然性能和精度上存在一定差距，但通过一些优化优化，已满足本阶段的功能需求，是更具性价比的选择。

#### `auipc` 指令在硬件与软件实现上的比较分析

**硬件方案实现：**

在 CPU 执行 `auipc` 指令阶段，硬件需将当前的 PC（程序计数器）值与立即数左移 12 位的结果相加，并将最终结果写入指定目的寄存器。具体过程包括：立即数解码与扩展、移位操作、PC 读取、加法器运算以及写回寄存器堆。由于立即数偏移与 PC 值均在指令译码期可确定，硬件可以在单周期内完成此运算。

该方案的主要优势在于运行效率高，不依赖额外的指令组合或跳转逻辑，即可完成对 PC 相对地址的构造。该指令通常用于跳转地址生成或全局变量寻址，因此在系统中属于高频使用指令。其硬件实现结构简单、资源消耗低，可有效集成于 ALU 数据通路中。

**软件方案实现：**

由于软件无法直接访问当前 PC 值，因此在不支持 `auipc` 指令的情况下，需要通过伪跳转手段间接获取 PC，然后再与偏移量相加。在当前地址执行一次 `jal` 到一个标签，借用 `ra` 保存的返回地址作为 PC 近似值，再与移位后的立即数相加写入目标寄存器。

```
jal ra, here
here:
li   t0, 0x10
slli t0, t0, 12         # t0 = imm << 12
addi ra, ra, -4         # ra = PC
add  t1, ra, t0         # t1 = PC + (imm << 12)
```

这种方案的主要优势是功能可模拟、指令兼容性强，但缺点也非常明显：依赖多条指令组合，增加执行周期，跳转指令还可能对流水线造成扰动，严重影响程序控制流和性能。

**对比结果总结：**

| 比较维度    | 硬件实现                         | 软件实现                                   |
| ----------- | -------------------------------- | ------------------------------------------ |
| 性能        | 单周期执行，构造地址效率高       | 借用跳转获取 PC，效率低、破坏流水线        |
| 精度/正确性 | 精确取当前 PC，无偏差            | 跳转可能引起偏移误差，不适合高精度地址构造 |
| 实现难度    | 结构清晰，需接入 PC 与立即数通路 | 依赖跳转逻辑，代码维护复杂                 |
| 可调试性    | 结果可直接观测，调试方便         | 调试依赖跳转地址及寄存器状态，误差定位困难 |

**最终选择说明：**

考虑到 `auipc` 指令在地址构造中的关键作用，以及其对执行效率和流水线行为的显著影响，我们在本项目中采用了**硬件实现方案**。通过在数据通路中接入 PC 与立即数移位后结果的加法逻辑，可快速生成跳转偏移，确保了高效的跳转与寻址能力。

#### `lui` 指令硬件与软件实现上的比较分析

**硬件方案实现：**

在 `lui` 指令的硬件实现中，CPU 在译码阶段将指令中提供的 20 位立即数直接左移 12 位，然后写入目的寄存器的高 20 位，低 12 位补零。该过程不依赖寄存器读取或复杂运算，基本可由立即数字段解码模块与位移逻辑一拍完成。其逻辑清晰、延迟低，是典型的常量加载指令。

该方案的优势在于指令路径短、实现简单、执行快速，并能为后续的 `addi` 等指令提供基础地址或立即数，常用于加载大数或初始化指针变量。

**软件方案实现：**

在无 `lui` 支持的情况下，可通过清零、移位和加法组合实现类似功能。例如，先将寄存器清零，再通过多条 `addi` 和 `slli` 指令将高位常量写入。这种方法虽然可行，但操作繁琐，占用多条指令，影响代码简洁性和执行性能。

```
# 模拟 x5 = 0x12345000

li    x5, 0x123     # 加载高位部分（近似高 20 位的前几位）
slli  x5, x5, 12    # x5 = x5 << 12，相当于乘以 2^12，即 x5 = 0x123000

addi  x5, x5, 0x450 # 加上低 12 位部分（0x450 = 0x12345000 的低 12 位）
                    # x5 = 0x123000 + 0x450 = 0x123450
slli  x5, x5, 4     # 再左移 4 位补足，x5 = 0x1234500
slli  x5, x5, 4     # 再左移 4 位，x5 = 0x12345000（目标完成）
```

此外，软件模拟版本容易受立即数表示范围和符号扩展的影响，构造特定高位常量时还需特殊处理，带来额外的复杂度和出错风险。

**对比结果总结：**

| 比较维度         | 硬件实现                           | 软件实现                                 |
| ---------------- | ---------------------------------- | ---------------------------------------- |
| 性能             | 单周期加载高位立即数，效率极高     | 多条指令组合，耗时长                     |
| 实现难度         | 非常低，仅需立即数移位后写入寄存器 | 简单，但实现繁琐，依赖额外指令           |
| 灵活性           | 直接支持大常量加载，便于地址构造   | 逻辑不统一，易引发异常                   |
| 可读性与可维护性 | 单条指令语义明确，程序结构清晰     | 指令组合形式多样，可读性差，增加理解成本 |

**最终选择说明：**

基于 `lui` 指令的广泛用途及其对程序结构的优化作用，我们在本项目中采用了**硬件实现方案**。其实现逻辑简单，资源开销小，能在保证性能的同时，简化代码生成与常量管理，是 RISC-V 架构中不可或缺的基本指令之一。



### 系统上板使用说明

1. **复位** ：复位信号采用开发板上自带的`reset`按钮，当按下后所有的存储数据的变量内的数据会变为初始值并且回到输入测试样例编号的步骤。
2. 最右侧三个按键代表输入的样例编号，按下确定键后进入该样例，通过左侧8个按键输入相应信息。（系统会根据输入地址判断应该读取什么信息）
3. LED或数码管（根据输入的地址）会依据switch的输入内容输出相应的结果。
   - LED灯为store的二进制值
   - 数码管则是十六进制数字或十进制数字

### 自测试说明

| 测试用例 | 测试方法  | 测试类型 |                         测试用例说明                         | 测试结果 |
| :------: | :-------: | :------: | :----------------------------------------------------------: | :------: |
|   1-0    | 仿真+上板 |   单元   |              输入a=2，b=3，LED灯显示二进制编码               |   通过   |
|   1-1    | 仿真+上板 |   单元   |               输入10000001，数码管显示FFFFFF81               |   通过   |
|   1-2    | 仿真+上板 |   单元   |               输入10000001，数码管显示00000081               |   通过   |
|   1-3    | 仿真+上板 |   单元   |                    两数不相等，LED灯不亮                     |   通过   |
|   1-4    | 仿真+上板 |   单元   |                         a<b，LED灯亮                         |   通过   |
|   1-5    | 仿真+上板 |   单元   |                  由于是unsigned，LED灯不亮                   |   通过   |
|   1-6    | 仿真+上板 |   单元   |                   a<b，赋值为1，1个LED灯亮                   |   通过   |
|   1-7    | 仿真+上板 |   单元   |              由于是unsigned，赋值为0，LED灯不亮              |   通过   |
|   2-0    | 仿真+上板 |   集成   |                  输入10101001，输出10010101                  |   通过   |
|   2-1    | 仿真+上板 |   集成   |        输入10000001，LED灯亮；输入10000000，LED灯不亮        |   通过   |
|   2-2    | 仿真+上板 |   集成   | 输入2.5的浮点数，显示十进制数2；输入-2.5的浮点数，显示十进制数-2 |   通过   |
|   2-3    | 仿真+上板 |   集成   |                        两者相加等于0                         |   通过   |
|   2-4    | 仿真+上板 |   集成   |                    输入1000，输出10001011                    |   通过   |
|   2-5    | 仿真+上板 |   集成   |      输入10001011，1个LED灯亮；输入10001010，无LED灯亮       |   通过   |
|   2-6    | 仿真+上板 |   集成   |                   输入12345，显示12345000                    |   通过   |
|   2-7    | 仿真+上板 |   集成   |                  显示1，按下confirm，显示2                   |   通过   |

#### 测试结论

测试用例2-3中没有测试负数和负数相加的情况导致出现了错误，错误的原因是在得到浮点数后先进行了移位后进行了相加，部分小数被忽略，相加可能出现进位问题。代码中改为先相加后移位修复了该问题。

### 开源及AI 对于本次大作业的启发和帮助

> 本次Project借助了网络开源代码以及生成式AI的帮助

**网络开源代码**：在本次开发过程中，我们主要参考了 GitHub 上关于数码管走马灯程序和 VGA 显示模块的开源代码。尽管参考了现有的走马灯程序，但在测试初期，数码管始终无法同时显示 8 个不同的数字。通过逐个关闭数码管进行排查，我们最终发现问题出在 数码管相关的约束（constraint）连接方向相反，导致左四位与右四位数码管始终显示相同的内容。对于 VGA 模块，我们在最初测试时遇到了无法在显示器上正常显示图像的问题。最终通过更换 VGA 线材与显示器，并调整 reset 的复位信号，成功修复了相关代码漏洞，保证了图像的正确输出。

**AI**：鉴于 CPU 模块代码的复杂性，我们小组并未直接使用 AI 生成代码，而是主要借助 AI 提供设计思路与问题排查建议。例如，在测试失败时，我们会向 AI 询问某条指令可能涉及的模块，从而指导我们逐一定位问题。此外，我们也利用 AI 协助编写部分基础指令的测试汇编代码，以提高调试效率，加快基础指令功能的验证过程。

### 问题以及总结

#### 问题

- 时钟周期出现问题导致仿真测试可以通过，但是上板之后数码管一直无法显示
  - 通过调整时钟周期频率解决问题
- 内存无法成功存储输入内容
- 理解IO的输入输出逻辑与测试场景的结合出现困难
- jal和jalr无法正确跳转到正确位置
  - 通过增加pc_out输出保存pc信息
- 起初没有考虑到测试场景2需要能过显示十进制数字

#### 总结

CPU 项目的难点主要在于调试。在这个过程中，你可能需要编写大量汇编代码，并进行多次仿真，才能开始上板测试。仿真时，常常需要逐个变量跟踪排查，才能找出真正出问题的地方，最后整个屏幕都布满了红红绿绿的波形图。

当我们确认仿真没有问题后，还需要花费较长时间等待比特流文件的生成。如果上板测试仍然出错，就只能重新开始整个流程。总之，整个调试过程复杂而漫长，不建议未来的小组把这个项目留到最后几天再完成，否则很可能会因为问题难以定位而彻夜奋战仍无结果。

当然也正因如此，这个项目仍然让我们深入理解并掌握了单周期 CPU 的实现逻辑，收获颇丰。

### Bonus 对应功能点的设计说明

#### 1. 实现扩展指令

##### auipc的实现

将PC左移12位，然后存入rd寄存器，在我们的测试样例中，我们将jalr_target地址，通过auipc命令+addi命令导入寄存器，然后通过jalr命令进行跳转。

其中的核心代码如下：

```
.text
.globl _start

_start:
    li t1, 1
    addi t1, t1, 1
    auipc t0, 0x12345     # t0 = PC + (0x12345 << 12) = PC + 0x12345000

    li t2, 0xfffffff0     # 数码管显示地址
    sw t0, 0(t2)          # 输出 t0 到数码管

loop:
    j loop                # 保持循环
```

该指令在测试场景2-7中得到测试。

#### 2. uart实现

##### 设计思路

实现 可复用的 UART 程序加载机制：用户只需烧写一次比特流，之后可通过串口动态将不同的 `.inst` 和 `.mem` 文件加载进指令和数据存储模块，灵活切换多个测试场景。

##### 核心配置与代码说明

##### 1. UART IP核添加与配置

- 使用 Vivado IP Catalog 中 `uart_bmpg_v1_3`
- 设置：10MHz 输入时钟、128000 baud、8位数据、1个停止位

##### 2. 新建专用 UART 时钟

- `cpuclk` IP 核中添加新输出 `clk_out2`，频率为 `10 MHz`，用于 UART 通信（图2）
- 由该时钟驱动 UART 模块，使之独立于 CPU 主时钟运行

##### 3. `CPU_TOP` 顶层接口与控制逻辑

- 增加 UART 输入/输出端口：`start_pg`, `rx`, `tx`
- 增加状态管理寄存器 `upg_rst`，通过 `fpga_rst` 与 `start_pg` 控制进入 UART 加载状态（图3-4）
- 定义 `kickOff = upg_rst_i | (~upg_rst_i & upg_done_i)`
  - `kickOff=0`：UART加载状态；
  - `kickOff=1`：正常运行状态

```
  wire upg_clk_o;
    wire upg_wen_o;      //Uart write out enable
    wire upg_done_o;     //Uart rx data have done
    //data to which  memory unit of program_rom/dmemory32 
    wire [14:0] upg_adr_o;     
    //data to program_rom or dmemory32 
    wire [31:0] upg_dat_o; 

    wire spg_bufg;
        
    // de-twitter
    BUFG U1 (.I(start_pg), .O(spg_bufg));
    
    reg upg_rst;
    // UART编程复位信号
    always @(posedge clk) begin
        if (spg_bufg) begin
            upg_rst <= 0;           // UART编程复位信号
        end
        else begin
            upg_rst <= 1;           // UART编程复位信号
        end
    end

    wire rst;      
    assign rst = reset | !upg_rst;

    uart_bmpg_0 uart_prog (
        .upg_clk_i   (upg_clk),      // 分频后的10MHz时钟
        .upg_rst_i   (upg_rst),      // UART复位信号（由 start_pg 生成）
        .upg_rx_i    (rx),           // 串口接收引脚
        .upg_clk_o   (upg_clk_o),    // 输出给其他模块（如 RAM）
        .upg_wen_o   (upg_wen_o),    // 写使能
        .upg_adr_o   (upg_adr_o),    // 写地址（高位用于区分 program/data）
        .upg_dat_o   (upg_dat_o),    // 写数据
        .upg_done_o  (upg_done_o),   // 写入完成标志
        .upg_tx_o    (tx)            // 串口发送引脚（可用于回显等）
    );
```



##### 4. 存储模块适配（ROM / RAM）

- `dmemory32` 和 `programrom` 均支持双输入来源（图5-6）：
  - 正常工作模式下使用 `cpu_clk` 和 `CPU` 的访问信号；
  - UART 模式下使用 `uart_clk` 和 `uart_bmpg` 的地址/数据线。
- 通过 `kickOff` 信号选择数据来源

```

    wire kickOff = upg_rst_i | (~upg_rst_i & upg_done_i);
    
    wire [13:0] ram_addr = kickOff ? addr[15:2] : upg_adr_i;
        
    wire [31:0] ram_data = kickOff ? d_in        : upg_dat_i;
    // 时钟、写使能、地址、写数据，按模式多路选择
    wire ram_we   = kickOff ? m_write     : upg_wen_i;
```

