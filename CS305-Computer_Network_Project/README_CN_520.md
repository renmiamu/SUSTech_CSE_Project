# CS305 2025 春季学期最终项目 - 区块链网络模拟

**我们将根据本规范的最新版本对所有项目进行评分。请仔细阅读本项​​目规范并跟踪更新！！！**。

**重要提示：我们尽最大努力使本规范尽可能清晰，并涵盖测试过程中遇到的所有问题。但是，我们仍然可能在本规范中遗漏重要细节。如果有任何不清楚的地方，您应该在此存储库中提交问题或立即联系教师和助教，而不是猜测您必须做什么。同样，如果您有任何问题，请在开始之前与教师和助教确认**。

## 1. 引言

比特币 (BTC) 和以太坊 (ETH) 是最广为人知且最安全的加密货币系统之一。它们允许用户传输数字货币（例如 BTC 和 ETH），而无需透露其身份或依赖银行或支付宝等中心化平台。这些功能是通过**区块链技术**实现的。

区块链是一个去中心化的账本，它存储着一个不断扩展的记录序列，称为**区块**，这些区块通过加密哈希安全地连接在一起。每个区块包含前一个区块的哈希值、一个时间戳和一系列交易（通常组织成一个默克尔树，交易位于叶子节点）。这种设计形成了一种链式结构，其中每个区块都链接到其前一个区块，类似于链表。因为每个区块都依赖于前一个区块的完整性，所以追溯性地修改数据将需要修改所有后续区块并在整个网络中达成**共识**。这使得区块链系统具有高度的抗篡改性，并有助于防止双重支付、伪造、欺诈和未经授权创建资产等问题。

我们以以太坊为例。以太坊是一个公共区块链，任何对等方都可以自由加入或离开。系统中的实体称为区块链对等方（以下简称**对等方**），它们不仅可以生成交易，还可以验证其他对等方生成的交易，并将有效交易打包成区块的形式。然后，这些区块由系统中的所有对等方验证，如果大多数对等方接受它们，则链接到区块链。这个过程称为**区块链共识**（即区块生成和验证）。在这里，每个对等方都在本地存储区块链的副本。因此，一个区块被链接到区块链意味着每个对等方都在其本地区块链中存储该区块。区块链共识确保所有对等方存储相同的区块链副本。

<div align="center">

<img src="Blockchain_Process.jpg" alt="描述" width="700"/>

<p><em>图 1：区块链系统如何运作（节点 = 对等方）。</em></p>

</div>

在每个区块周期（即生成一个区块的时间间隔）中，基本操作是：

1. 对等方生成新的交易并将其广播到系统中的所有对等方。
2. 选择一个对等方作为区块生成者，将交易打包成一个区块。
3. 新区块被广播到系统中的所有对等方。
4. 对等方验证区块的有效性。
5. 如果大多数对等方接受该区块，则该区块将附加到区块链中。因此，区块中的交易将永久存储在区块链中。恶意对等方意图修改区块链中的区块将更改所有后续区块，这需要所有对等方重新验证这些区块；这在比特币中被认为是不可行的。

本项目侧重于模拟这种区块链系统中的对等 (P2P) 通信。要模拟的核心功能包括：

- 对等方初始化
- 对等方发现
- 消息发送/接收
- 交易和区块生成
- 仪表盘监控

要实现的功能总结在图 2 中。

<!---
在这个项目中，我们将重点关注区块链系统中的对等方如何通信以交换数据（例如交易和区块）。从图 1 中我们可以看到，区块链系统是基于**对等 (P2P) 网络**实现的，在该网络中，对等方直接交换数据，没有任何中心化实体。该项目旨在模拟此区块链 P2P 网络，其中包括**对等方发现**、**发送消息处理**和**接收消息处理**的功能。此外，为了交换交易和区块，模拟了简化的**交易和区块生成**。最后，在运行对等方之前必须进行**对等方初始化**，并使用**仪表盘**来观察网络的操作。要实现的功能总结在图 2 中。
-->

<div align="center">

<img src="Functionalities.jpg" alt="描述" width="700"/>

<p><em>图 2：本项目中要完成的功能。</em></p>

</div>

-------------------

## 2. 区块链 P2P 网络的功能

<div align="center">

<img src="Functionality_Relationship.jpg" alt="描述" width="700"/>

<p><em>图 3：不同功能如何交互。</em></p>

</div>

图 3 显示了不同功能之间的关系。下面描述了系统的每个核心组件。

-----

### 第 1 部分：对等方初始化

加入网络后，对等方：
* 配置其 `IP 地址`、`端口`和 `gossip 扇出`，并且
* 选择其角色：`普通`或`恶意`，`轻量级`或`完整`，`NAT` 或 `非 NAT`。
* 初始化一个 TCP 套接字以接收传入消息。

**关键术语：**
* `gossip 扇出`：在区块链中，对等方在广播区块和交易时通常采用 gossip 协议。也就是说，每个对等方将区块或交易发送到一个随机子集，而不是其所有已知对等方。这可以减少网络中的冗余消息。在这里，`gossip 扇出`表示广播区块和交易时的目标对等方数量。
* `普通`或`恶意`对等方：普通对等方总是生成正确的交易和区块。相反，恶意对等方可以生成不正确的交易和区块（例如，具有错误的区块 ID）。
* `轻量级`或`完整`对等方：在引言中，我们介绍所有对等方都验证区块并存储区块链的副本，这称为完整对等方。然而，在实践中，存在一些资源受限的设备（例如，移动电话和笔记本电脑），它们没有足够的计算和存储能力来验证和存储所有区块。为了解决这个问题，以太坊允许对等方充当轻量级对等方，它们不验证区块也不存储所有区块。相反，轻量级对等方存储没有交易的区块头。
* `NAT` 或 `非 NAT` 对等方：本项目考虑网络地址转换 (NAT)。NAT 对等方通常位于本地网络中，不能直接与本地网络外部的对等方交互。相反，本地网络中的非 NAT 对等方充当 NAT 路由器或 NAT 对等方与本地网络外部对等方之间的中继对等方。通常，在将外部消息转发到本地网络中的对等方时，中继对等方必须根据 NAT 转换表找到目标对等方在本地网络中的 IP 地址。在这里，为了降低复杂性，我们只模拟 NAT 的逻辑并忽略 NAT 转换表；也就是说，NAT 对等方在整个网络中只有一个 IP 地址。

-----

### 第 2 部分：对等方发现

创建 TCP 套接字后，对等方会将其存在通知已知的对等方，以便交换数据。为此，对等方必须在加入网络之前获取一些对等方的 IP 地址和端口。

此外，对等方需要定期检查已知对等方是否处于活动状态。

对等方发现的过程如下：

* 加入网络时向其已知对等方发送 `hello` 消息。
* 当收到 `hello` 消息时，检查发送方是否已知。如果不是，则将发送方添加到已知对等方列表中。
* 定期向所有已知对等方发送 `ping` 消息并等待其回复，即 `pong` 消息。
* 当收到 `pong` 消息时，更新已知对等方的状态。此外，计算发送 `ping` 消息和接收 `pong` 消息之间的时间差，即对等方之间的传输延迟。
* 如果在超时之前未收到 `pong` 消息，则删除无响应的对等方。

------

### 第 3 部分：区块和交易生成与验证

在初始化对等方并找到已知对等方之后，完整对等方开始生成和验证交易和区块。在这个项目中，每个完整对等方定期生成一个交易并将其广播给其他完整对等方进行验证。

如果交易 ID 正确，则交易有效。这些交易也存储在对等方的本地交易池 `tx_pool` 中。

由于我们只关注区块链 P2P 网络中的交易和区块交换，因此我们在这里简化了区块生成。在每个区块周期中，每个对等方不是选择一个区块生成者来生成区块，而是独立地将其 `tx_pool` 中的交易打包成一个区块，并将其广播给其他对等方进行验证。如果 `区块 ID` 正确，则区块有效。

交易/区块生成和验证的过程如下：

* 加入网络时从已知对等方同步最新的区块链，以便将新区块链接到最新的区块链。
* 开始生成交易。
* 将交易广播给已知对等方进行验证。
* 将有效交易添加到本地 `tx_pool`。
* 将本地 `tx_pool` 中的交易打包成一个新区块。
* 将区块广播给已知对等方进行验证。
* 将有效区块添加到本地区块链。

**提示：**
* 当一个对等方将区块发送给另一个对等方时，发送方通常发送一个带有区块 ID 的 `INV` 消息，而不是区块本身。如果接收方发现它尚未收到该区块，接收方将回复一个 `GETBLOCK` 消息以请求该区块。这可以减少网络开销。

------

### 第 4 部分：发送消息处理

为了模拟发送消息（例如交易和区块）的过程，所有发送的消息都必须放入一个发件箱队列中并逐个发送。发送消息的过程如下：

* 发送消息时，将消息添加到发件箱队列。
* 根据优先级从队列中读取消息。
* 如果消息目标是非 NAT 对等方，则直接将消息发送到目标。
* 如果消息目标是 NAT 对等方，则找到最佳中继对等方并将消息发送到中继对等方。

--------

### 第 5 部分：接收消息处理

当从其他对等方接收消息时，必须根据消息类型分派和处理消息。接收消息处理如下：

* 检查消息发送方是否被禁止。如果发送方被禁止，则丢弃消息。
* 检查发送方发送的消息数量是否在限制范围内。如果发送方发送消息过于频繁，则丢弃消息。这是为了防止拒绝服务 (DoS) 攻击。
* 检查消息类型并相应地处理消息：

  * msg.type=`TX`,
    * 检查交易的有效性。如果无效，则丢弃交易并记录发送方的违规行为。
    * 检查交易是否已收到。如果是，则丢弃交易以防止重放攻击。
    * 如果已收到冗余交易，则记录冗余交易的计数。
    * 如果尚未收到新交易，则将其添加到本地 `tx_pool`。
    * 将新交易广播给已知对等方。

  * msg.type=`BLOCK`,
    * 检查区块的有效性。如果无效，则丢弃区块并记录发送方的违规行为。
    * 检查区块是否已收到。如果是，则丢弃区块以防止重放攻击。
    * 如果已收到冗余区块，则记录冗余区块的计数。
    * 如果由于网络延迟其前一个区块在区块链中不存在，则将新区块添加到孤立区块列表中。
    * 如果其前一个区块存在于区块链中，则将新区块添加到本地区块链。
    * 检查新区块是否是孤立区块的前一个区块。
    * 将新区块广播给已知对等方。

  * msg.type=`INV`,
    * 检查 INV 消息中的区块 ID 是否已收到。
    * 从消息发送方请求丢失的区块。

  * msg.type=`GETBLOCK`,
    * 检查请求的区块是否在本地区块链中。如果不在，则从已知对等方请求区块。
    * 如果发送方是完整对等方，则回复请求的区块。
    * 如果发送方是轻量级对等方，则回复请求区块的头部。

  * msg.type=`GET_BLOCK_HEADERS`
    * 回复本地区块链中区块的头部。

  * msg.type=`BLOCK_HEADERS`
    * 通过检查每个区块的前一个区块是否存在于区块链中来检查区块头列表的有效性。
    * 如果对等方是完整对等方，则从已知对等方请求丢失的区块。

-------

### 第 6 部分：启动仪表盘

启动仪表盘服务器以显示以下消息：

* `Localhost:port/peers`：显示已知对等方的集合。
* `Localhost:port/transactions`：显示本地池中的交易。
* `Localhost:port/blocks`：显示本地区块链中的区块。
* `Localhost:port/orphan`：显示孤立区块。
* `Localhost:port/latency`：显示对等方之间的传输延迟。
* `Localhost:port/capacity`：显示对等方的发送能力。
* `Localhost:port/redundancy`：显示收到的冗余消息数量。

-------

## 3. 要完成的功能

项目的操作逻辑在 `node.py` 的 `Main` 函数中给出。您的任务是实现以下模块：

-------

### 第 1 部分：对等方初始化 (`socket_server.py`)

1. `start_socket_server`

* 创建一个 TCP 套接字并将其绑定到对等方的 IP 地址和端口。
* 开始在套接字上侦听以接收传入消息。
* 当接收到消息时，将消息传递给 `message_handler.py` 中的 `dispatch_message` 函数。

-------

### 第 2 部分：对等方发现

#### `peer_discovery.py`：此部分负责在对等方加入系统时向已知对等方发送"hello"消息。

1. `start_peer_discovery`

* 定义 `hello` 消息的 JSON 格式，其中应包括：`{消息类型、发送方 ID、IP 地址、端口、标志和消息 ID}`。`发送方 ID` 可以是 `peer_port`。`标志`应指示对等方是 `NAT` 还是 `非 NAT`，以及是 `完整` 还是 `轻量级`。`消息 ID` 可以是随机数。
* 向所有已知对等方发送 `hello` 消息，并将消息放入发件箱队列。

2. `handle_hello_message`

* 读取接收到的 `hello` 消息中的信息。
* 如果发送方未知，则将其添加到已知对等方列表 (`known_peer`) 并记录其标志 (`peer_flags`)。
* 更新可达对等方的集合 (`reachable_by`)。

**提示：** 每个对等方只能从可达对等方接收 `hello` 消息，并且从不转发 `hello` 消息。如果对等方从 NAT 对等方接收 `hello` 消息，则它可以充当 NAT 对等方的中继对等方。

#### `peer_manager.py`：此部分负责检查已知对等方的状态并记录其性能。

1. `start_ping_loop`

* 定义 `ping` 消息的 JSON 格式，其中应包括 `{消息类型、发送方 ID、时间戳}`。

* 定期向每个已知对等方发送 `ping` 消息。

2. `create_pong`

* 创建 `pong` 消息的 JSON 格式，其中应包括 `{消息类型、发送方 ID、接收到的 ping 消息中的时间戳}`

3. `handle_pong`

* 读取接收到的 `pong` 消息中的信息。

* 更新对等方与发送方之间的传输延迟 (`rtt_tracker`)。

4. `start_peer_monitor`

* 检查从 `last_ping_time` 中的每个对等方接收 `ping` 或 `pong` 消息的最新时间。

* 如果最新时间早于限制，则将 `peer_status` 中的对等方状态标记为 `UNREACHABLE`，否则标记为 `ALIVE`。

5. `update_peer_heartbeat`

* 在收到对等方的 `ping` 或 `pong` 消息时更新其 `last_ping_time`。

6. `record_offense`

* 当检测到恶意行为时，记录对等方的违规次数。

* 如果对等方的违规次数超过 3 次，则将其添加到 `blacklist`。

--------

### 第 3 部分：区块和交易生成与验证

#### `transaction.py`：此部分处理所有与交易相关的功能。

1. `transaction_generation`

* 从 `known_peers` 中随机选择一个对等方，并生成一个向该对等方转任意金额的交易。

* 使用 `add_transaction` 函数将交易添加到本地 `tx_pool`。

* 使用 `outbox.py` 中的 `gossip_message` 函数将交易广播到 `known_peers`。

2. `add_transaction`

* 如果交易在池中，则将其添加到本地 `tx_pool`。

* 将交易 ID 添加到 `tx_ids`。

3. `get_recent_transaction`

* 返回本地 `tx_pool` 中的所有交易。

4. `clear_pool`

* 删除 `tx_pool` 中的所有交易和 `tx_ids` 中的交易 ID。

#### `block_handler.py`：此部分处理所有与区块相关的功能。

1. `request_block_sync`

* 定义 `GET_BLOCK_HEADERS` 的 JSON 格式，其中应包括 `{消息类型、发送方 ID}`。

* 向每个已知对等方发送 `GET_BLOCK_HEADERS` 消息（以获取最新区块链中区块头的列表），并将消息放入发件箱队列。

2. `block_generation`

* 使用 `create_dummy_block` 函数定期创建一个新区块。

* 使用 `inv_message.py` 中的 `create_inv` 函数为新区块创建一个 `INV` 消息。

* 使用 `outbox.py` 中的 `gossip` 函数将 `INV` 消息广播到已知对等方。

3. `create_dummy_block`

* 定义 `block` 的 JSON 格式，其中应包括 `{消息类型、对等方 ID、时间戳、区块 ID、前一个区块的 ID 和交易}`。`区块 ID` 是区块结构的哈希值，但不包括 `区块 ID` 项。`前一个区块` 是区块链中的最后一个区块，新区块将链接到该区块。如果区块生成者是恶意的，它可以生成一个随机区块 ID。

* 在清除本地交易池之前，使用 `transaction.py` 中的 `get_recent_transactions` 函数读取本地 `tx_pool` 中的交易。

* 使用交易创建一个新区块，并使用 `compute_block_hash` 函数生成区块 ID。

* 将新区块添加到本地区块链 (`receive_block`)。

4. `compute_block_hash`

* 计算除 `区块 ID` 项之外的区块哈希值。

5. `handle_block`

* 检查接收到的区块中 `区块 ID` 的正确性。如果不正确，则丢弃该区块并记录发送方的违规行为。

* 检查该区块是否存在于本地区块链中。如果是，则丢弃该区块。

* 检查该区块的前一个区块是否存在于本地区块链中。如果不存在，则将该区块添加到孤立区块列表 (`orphan_blocks`)。如果存在，则将该区块（对于完整对等方）或区块头（对于轻量级对等方）添加到本地区块链。

* 检查该区块是否是 `orphan_blocks` 中区块的前一个区块。如果是，则将孤立区块添加到本地区块链。

6. `create_getblock`

* 定义 `GETBLOCK` 消息的 JSON 格式，其中应包括 `{消息类型、发送方 ID、请求的区块 ID}`。

7. `get_block_by_id`

* 根据区块 ID 返回本地区块链中的区块。

#### inv_message.py：此部分在交换区块时处理 `INV` 消息。

1. `create_inv`

* 定义 `INV` 消息的 JSON 格式，其中应包括 `{消息类型、发送方 ID、发送区块的 ID、消息 ID}`。请注意，`INV` 消息在发送区块之前发送。`发送区块的 ID` 是发送方想要发送的区块的 ID。`消息 ID` 可以是由 `util.py` 中的 `generate_message_id` 生成的随机数。

2. `get_inventory`

* 返回本地区块链中所有区块的区块 ID。

3. `broadcast_inventory`

* 创建一个包含本地区块链中所有区块 ID 的 `INV` 消息。

* 使用 `outbox.py` 中的 `gossip_message` 函数将 `INV` 消息广播到已知对等方，以与已知对等方同步区块链。

---------

### 第 4 部分：发送消息处理 (outbox.py)

1. `enqueue_message`：此函数将所有发送的消息放入发件箱队列。

* 使用 `is_rate_limited` 函数检查对等方是否过于频繁地向接收方发送消息。如果是，则丢弃消息。

* 检查接收方是否存在于 `blacklist` 中。如果是，则丢弃消息。

* 使用 `classify_priority` 函数根据消息类型对发送消息的优先级进行分类。

* 如果队列长度在限制 `QUEUE_LIMIT` 内，则将消息添加到队列 (`queues`)，否则丢弃消息。

2. `is_rate_limited`

* 检查在当前结束的 `TIME_WINDOW` 期间从对等方向目标对等方发送了多少条消息。

* 如果发送频率超过发送速率限制 `RATE_LIMIT`，则返回 `TRUE`；否则，将当前发送时间记录到 `peer_send_timestamps` 中。

3. `classify_priority`

* 根据消息类型对消息的优先级进行分类。

4. `send_from_queue` (`outbox.py`)

* 读取队列中的消息。每次读取目标对等方具有最高优先级的一条消息。发送消息后，读取下一个目标对等方的消息。这确保了向不同目标对等方发送消息的公平性。

* 使用 `relay_or_direct_send` 函数发送消息，该函数将决定是直接将消息发送到目标对等方还是通过中继对等方发送。

* 如果消息发送失败，则重试该消息，如果重试次数超过限制 `MAX_RETRIES`，则丢弃该消息。

5. `relay_or_direct_send`

* 检查目标对等方是否是 NAT 对等方。

* 如果目标对等方是 NAT 对等方，则使用 `get_relay_peer` 函数找到最佳中继对等方。定义 `RELAY` 消息的 JSON 格式，其中应包括 `{消息类型、发送方 ID、目标对等方 ID、有效负载}`。`有效负载` 是发送的消息。使用 `send_message` 函数将 `RELAY` 消息发送到最佳中继对等方。

* 如果目标对等方是非 NAT 对等方，则使用 `send_message` 函数将消息发送到目标对等方。

6. `get_relay_peer`

* 在 `peer_discovery.py` 的 `reachable_by` 中找到可从目标对等方访问的中继候选集。

* 读取 `peer_manager.py` 中 `rtt_tracker` 中发送方与其他对等方之间的传输延迟。

* 选择并返回具有最小传输延迟的最佳中继对等方。

7. `send_message`

* 将消息发送到目标对等方。使用 `apply_network_condition` 函数中的动态网络条件包装 `send_message` 函数。

8. `apply_network_conditions`：此函数模拟对等方的发送容量控制、消息丢失和消息传输延迟。

* 使用 `rate_limiter.allow` 函数检查对等方的发送速率是否超出限制。如果是，则丢弃消息并更新丢弃状态 (`drop_stats`)。

* 生成一个随机数。如果它小于 `DROP_PROB`，则丢弃消息以模拟通道中的随机消息丢失。更新丢弃状态 (`drop_stats`)。

* 在发送消息之前添加一个随机延迟以模拟消息传输延迟。

* 使用 `send_func` 函数发送消息。

9. `start_dynamic_capacity_adjustment`

* 定期更改 `rate_limiter` 中对等方的发送容量，范围在 [2, 10] 内。

10. `gossip_message`

* 读取 `peer_discovery.py` 中 `peer_config` 中对等方的配置 `fanout`。

* 从 `known_peers` 中随机选择等于 `fanout` 的目标对等方数量。如果 gossip 消息是交易，则跳过 `know_peers` 中的轻量级对等方。

* 将消息发送到选定的目标对等方并将其放入发件箱队列。

11. `get_outbox_status`

* 返回发件箱队列中的消息。

12. `get_drop_stats`

* 返回丢弃状态 (`drop_stats`)。

--------

### 第 5 部分：接收消息处理 (message_handler.py)

1. `dispatch_message`

* 读取消息。

* 检查消息是否已在 `seen_message_ids` 中出现以防止重放攻击。如果是，则丢弃消息并将 `message_redundancy` 加一。如果不是，则将消息 ID 添加到 `seen_message_ids`。

* 使用 `in_bound_limited` 函数检查发送方是否过于频繁地发送消息。如果是，则丢弃消息。

* 检查发送方是否存在于 `peer_manager.py` 的 `blacklist` 中。如果是，则丢弃消息。

* 根据消息类型处理消息：

   * msg_type == "RELAY":
        * 检查对等方是否是目标对等方。
        * 如果是，则提取有效负载并调用 `dispatch_message` 函数来处理有效负载。
        * 如果不是，则使用 `outbox.py` 中的 `enqueue_message` 函数将消息转发到目标对等方。

   * msg_type == "HELLO"
        * 调用 `peer_discovery.py` 中的 `handle_hello_message` 函数来处理消息。

   * msg_type == "BLOCK"
        * 检查区块 ID 的正确性。如果不正确，则使用 `peer_manager.py` 中的 `record_offence` 函数记录发送方的违规行为。
        * 调用 `block_handler.py` 中的 `handle_block` 函数来处理区块。
        * 调用 `create_inv` 函数为该区块创建一个 `INV` 消息。
        * 使用 `outbox.py` 中的 `gossip_message` 函数将 `INV` 消息广播到已知对等方。

   * msg_type == "TX"
        * 检查交易 ID 的正确性。如果不正确，则使用 `peer_manager.py` 中的 `record_offence` 函数记录发送方的违规行为。
        * 使用 `transaction.py` 中的 `add_transaction` 函数将交易添加到 `tx_pool`。
        * 使用 `outbox.py` 中的 `gossip_message` 函数将交易广播到已知对等方。

   * msg_type == "PING"
        * 使用 `peer_manager.py` 中的 `update_peer_heartbeat` 函数更新上次 ping 时间。
        * 使用 `peer_manager.py` 中的 `create_pong` 函数创建一个 `pong` 消息。
        * 使用 `outbox.py` 中的 `enqueue_message` 函数将 `pong` 消息发送到发送方。

   * msg_type == "PONG"
        * 使用 `peer_manager.py` 中的 `update_peer_heartbeat` 函数更新上次 ping 时间。
        * 调用 `peer_manager.py` 中的 `handle_pong` 函数来处理消息。

   * msg_type == "INV"
        * 使用 `block_handler.py` 中的 `get_inventory` 函数读取本地区块链中的所有区块 ID。
        * 将本地区块 ID 与消息中的区块 ID进行比较。
        * 如果存在丢失的区块，则创建一个 `GETBLOCK` 消息以从发送方请求丢失的区块。
        * 使用 `outbox.py` 中的 `enqueue_message` 函数将 `GETBLOCK` 消息发送到发送方。

   * msg_type == "GETBLOCK"
        * 从消息中提取区块 ID。
        * 使用 `block_handler.py` 中的 `get_block_by_id` 函数根据区块 ID 从本地区块链中获取区块。
        * 如果区块不在本地区块链中，则创建一个 `GETBLOCK` 消息以从已知对等方请求丢失的区块。
        * 使用 `outbox.py` 中的 `enqueue_message` 函数将 `GETBLOCK` 消息发送到已知对等方。
        * 重试从本地区块链获取区块。如果重试次数超过 3 次，则丢弃消息。
        * 如果区块存在于本地区块链中，则使用 `outbox.py` 中的 `enqueue_message` 函数将区块逐个发送给请求者。

   * msg_type == "GET_BLOCK_HEADERS"
        * 读取本地区块链中的所有区块头并将其存储在 `headers` 中。
        * 创建一个 `BLOCK_HEADERS` 消息，其中应包括 `{消息类型、发送方 ID、headers}`。
        * 使用 `outbox.py` 中的 `enqueue_message` 函数将 `BLOCK_HEADERS` 消息发送给请求者。

   * msg_type == "BLOCK_HEADERS"
        * 检查每个区块的前一个区块是否存在于本地区块链或接收到的区块头中。
        * 如果是并且对等方是轻量级对等方，则将区块头添加到本地区块链。
        * 如果是并且对等方是完整对等方，则检查本地区块链中是否存在丢失的区块。如果存在丢失的区块，则创建一个 `GET_BLOCK` 消息并将其发送给发送方。
        * 如果不是，则丢弃消息，因为接收到的消息中存在孤立区块，因此消息无效。

2. `is_inbound_limited`

* 记录从发送方接收消息时的时间戳。
* 检查发送方在 `INBOUND_TIME_WINDOW` 期间发送的消息数量是否超过 `INBOUND_RATE_LIMIT`。如果是，则返回 `TRUE`。如果不是，则返回 `FALSE`。

3. `get_redundancy_stats`

* 返回接收到重复消息的次数 (`message_redundancy`)。

---------

### 第 6 部分：仪表盘 (dashboard.py)

* `peers`：显示已知对等方的信息，包括 `{对等方 ID、IP 地址、端口、状态、NAT 或非 NAT、轻量级或完整}`。

* `transactions`：显示本地池 `tx_pool` 中的交易。

* `blocks`：显示本地区块链中的区块。

* `orphan`：显示孤立区块。

* `latency`：显示对等方之间的传输延迟。

* `capacity`：显示对等方的发送能力。

* `redundancy`：显示收到的冗余消息数量。

---------

## 4. 测试方法

本项目将基于 Docker 技术部署区块链 P2P 网络，其中每个对等方都在一个独立的容器中运行。在容器中运行对等方的过程可以概括如下：

1) 编写一个 `Dockerfile` 来为对等方构建一个容器镜像。该镜像可用于生成多个容器，即对等方。
2) 在 `docker-compose.yml` 中定义对等方，包括容器数量、容器运行方式以及它们之间的连接方式。
3) 使用 `docker compose build` 为 `docker-compose.yml` 中的所有服务构建镜像。
4) 使用 `docker compose up` 生成并启动 `docker-compose.yml` 中指定的容器。

我们已经在入门代码中提供了包含十个对等方的 `Dockerfile` 和 `docker-compose.yml`。使用这两个文件，我们将使用以下命令检查您的项目：
1) `docker compose up --build` 检查每个对等方是否正确运行。
2) `localhost:port/{parameter}` 检查对等方是否正确生成和传输交易和区块。

**额外加分：**
1) **动态区块链网络**：在上述测试方法中，区块链 P2P 网络中的对等方数量是固定的。您可以在项目中添加其他功能并修改 Docker 文件，以允许对等方动态加入或离开系统，而不会影响其他对等方的操作。为不同的新对等方使用不同的 `config.json`，以便新加入的对等方可能不知道网络中存在的所有对等方。

2) **冗余消息的原因**：探讨可能影响对等方收到的冗余消息数量的参数，例如，`fanout` 越大，传输到网络并由对等方接收的消息就越多。更改参数的值以观察对等方收到的冗余消息数量。绘制图形以显示它们之间的关系。

------------

## 5. 评分

**总分：100 分**

1) 对等方初始化 (5 分)
2) 对等方发现 (10 分)
3) 区块和交易生成与验证 (20 分)
4) 发送消息处理 (25 分)
5) 接收消息处理 (25 分)
6) 仪表盘 (5 分)
7) **期望提交一份关于实现细节、见解和改进的综合报告。(10 分)**


**额外加分：最高 20 分**
我们将根据您的实现进行评分。 